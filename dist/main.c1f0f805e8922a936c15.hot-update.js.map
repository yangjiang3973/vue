{"version":3,"sources":["file:////Users/yangjiang/dev/learn/vue/src/observer/index.js","file:///webpack/runtime/getFullHash"],"names":["arrayKeys","Object","getOwnPropertyNames","arrayMethods","shouldConvert","withoutConversion","fn","Observer","value","dep","Dep","def","isArray","augment","hasProto","protoAugment","copyAugment","observeArray","walk","prototype","obj","keys","i","l","length","convert","items","observe","key","val","defineReactive","addVm","vm","vms","push","removeVm","$remove","target","src","__proto__","ob","hasOwn","__ob__","isPlainObject","isExtensible","_isVue","property","getOwnPropertyDescriptor","configurable","getter","get","setter","set","childOb","defineProperty","enumerable","reactiveGetter","call","console","log","depend","e","reactiveSetter","newVal","notify"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA,IAAMA,SAAS,GAAGC,MAAM,CAACC,mBAAP,CAA2BC,gDAA3B,CAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,aAAa,GAAG,IAApB;AACO,SAASC,iBAAT,CAA2BC,EAA3B,EAA+B;AACpCF,eAAa,GAAG,KAAhB;AACAE,IAAE;AACFF,eAAa,GAAG,IAAhB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO,SAASG,QAAT,CAAkBC,KAAlB,EAAyB;AAC9B,OAAKA,KAAL,GAAaA,KAAb;AACA,OAAKC,GAAL,GAAW,IAAIC,yCAAJ,EAAX;AACAC,kDAAG,CAACH,KAAD,EAAQ,QAAR,EAAkB,IAAlB,CAAH,CAH8B,CAI9B;AACA;AACA;;AACA,MAAII,oDAAO,CAACJ,KAAD,CAAX,EAAoB;AAClB,QAAIK,OAAO,GAAGC,iDAAQ,GAAGC,YAAH,GAAkBC,WAAxC;AACAH,WAAO,CAACL,KAAD,EAAQL,gDAAR,EAAsBH,SAAtB,CAAP;AACA,SAAKiB,YAAL,CAAkBT,KAAlB;AACD,GAJD,MAIO;AACL,SAAKU,IAAL,CAAUV,KAAV;AACD;AACF,C,CAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAD,QAAQ,CAACY,SAAT,CAAmBD,IAAnB,GAA0B,UAAUE,GAAV,EAAe;AACvC,MAAIC,IAAI,GAAGpB,MAAM,CAACoB,IAAP,CAAYD,GAAZ,CAAX;;AACA,OAAK,IAAIE,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGF,IAAI,CAACG,MAAzB,EAAiCF,CAAC,GAAGC,CAArC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3C,SAAKG,OAAL,CAAaJ,IAAI,CAACC,CAAD,CAAjB,EAAsBF,GAAG,CAACC,IAAI,CAACC,CAAD,CAAL,CAAzB;AACD;AACF,CALD;AAOA;AACA;AACA;AACA;AACA;;;AAEAf,QAAQ,CAACY,SAAT,CAAmBF,YAAnB,GAAkC,UAAUS,KAAV,EAAiB;AACjD,OAAK,IAAIJ,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGG,KAAK,CAACF,MAA1B,EAAkCF,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5CK,WAAO,CAACD,KAAK,CAACJ,CAAD,CAAN,CAAP;AACD;AACF,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAf,QAAQ,CAACY,SAAT,CAAmBM,OAAnB,GAA6B,UAAUG,GAAV,EAAeC,GAAf,EAAoB;AAC/CC,gBAAc,CAAC,KAAKtB,KAAN,EAAaoB,GAAb,EAAkBC,GAAlB,CAAd;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAtB,QAAQ,CAACY,SAAT,CAAmBY,KAAnB,GAA2B,UAAUC,EAAV,EAAc;AACvC,GAAC,KAAKC,GAAL,KAAa,KAAKA,GAAL,GAAW,EAAxB,CAAD,EAA8BC,IAA9B,CAAmCF,EAAnC;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AAEAzB,QAAQ,CAACY,SAAT,CAAmBgB,QAAnB,GAA8B,UAAUH,EAAV,EAAc;AAC1C,OAAKC,GAAL,CAASG,OAAT,CAAiBJ,EAAjB;AACD,CAFD,C,CAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASjB,YAAT,CAAsBsB,MAAtB,EAA8BC,GAA9B,EAAmC;AACjC;AACAD,QAAM,CAACE,SAAP,GAAmBD,GAAnB;AACA;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAAStB,WAAT,CAAqBqB,MAArB,EAA6BC,GAA7B,EAAkCjB,IAAlC,EAAwC;AACtC,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGF,IAAI,CAACG,MAAzB,EAAiCF,CAAC,GAAGC,CAArC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3C,QAAIM,GAAG,GAAGP,IAAI,CAACC,CAAD,CAAd;AACAX,oDAAG,CAAC0B,MAAD,EAAST,GAAT,EAAcU,GAAG,CAACV,GAAD,CAAjB,CAAH;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEO,SAASD,OAAT,CAAiBnB,KAAjB,EAAwBwB,EAAxB,EAA4B;AACjC,MAAI,CAACxB,KAAD,IAAU,QAAOA,KAAP,MAAiB,QAA/B,EAAyC;AACvC;AACD;;AACD,MAAIgC,EAAJ;;AACA,MAAIC,mDAAM,CAACjC,KAAD,EAAQ,QAAR,CAAN,IAA2BA,KAAK,CAACkC,MAAN,YAAwBnC,QAAvD,EAAiE;AAC/DiC,MAAE,GAAGhC,KAAK,CAACkC,MAAX;AACD,GAFD,MAEO,IACLtC,aAAa,KACZQ,oDAAO,CAACJ,KAAD,CAAP,IAAkBmC,0DAAa,CAACnC,KAAD,CADnB,CAAb,IAEAP,MAAM,CAAC2C,YAAP,CAAoBpC,KAApB,CAFA,IAGA,CAACA,KAAK,CAACqC,MAJF,EAKL;AACAL,MAAE,GAAG,IAAIjC,QAAJ,CAAaC,KAAb,CAAL;AACD;;AACD,MAAIgC,EAAE,IAAIR,EAAV,EAAc;AACZQ,MAAE,CAACT,KAAH,CAASC,EAAT;AACD;;AACD,SAAOQ,EAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO,SAASV,cAAT,CAAwBV,GAAxB,EAA6BQ,GAA7B,EAAkCC,GAAlC,EAAuC;AAC5C,MAAIpB,GAAG,GAAG,IAAIC,yCAAJ,EAAV;AACA,MAAIoC,QAAQ,GAAG7C,MAAM,CAAC8C,wBAAP,CAAgC3B,GAAhC,EAAqCQ,GAArC,CAAf;;AACA,MAAIkB,QAAQ,IAAIA,QAAQ,CAACE,YAAT,KAA0B,KAA1C,EAAiD;AAC/C;AACD,GAL2C,CAO5C;;;AACA,MAAIC,MAAM,GAAGH,QAAQ,IAAIA,QAAQ,CAACI,GAAlC;AACA,MAAIC,MAAM,GAAGL,QAAQ,IAAIA,QAAQ,CAACM,GAAlC;AAEA,MAAIC,OAAO,GAAG1B,OAAO,CAACE,GAAD,CAArB;AACA5B,QAAM,CAACqD,cAAP,CAAsBlC,GAAtB,EAA2BQ,GAA3B,EAAgC;AAC9B2B,cAAU,EAAE,IADkB;AAE9BP,gBAAY,EAAE,IAFgB;AAG9BE,OAAG,EAAE,SAASM,cAAT,GAA0B;AAC7B,UAAIhD,KAAK,GAAGyC,MAAM,GAAGA,MAAM,CAACQ,IAAP,CAAYrC,GAAZ,CAAH,GAAsBS,GAAxC;;AACA,UAAInB,gDAAJ,EAAgB;AACdgD,eAAO,CAACC,GAAR,CAAY,CAAZ;AACAlD,WAAG,CAACmD,MAAJ;AACAF,eAAO,CAACC,GAAR,CAAY,CAAZ;;AACA,YAAIN,OAAJ,EAAa;AACXK,iBAAO,CAACC,GAAR,CAAY,CAAZ;AACAN,iBAAO,CAAC5C,GAAR,CAAYmD,MAAZ;AACD;;AACD,YAAIhD,oDAAO,CAACJ,KAAD,CAAX,EAAoB;AAClB,eAAK,IAAIqD,CAAJ,EAAOvC,CAAC,GAAG,CAAX,EAAcC,CAAC,GAAGf,KAAK,CAACgB,MAA7B,EAAqCF,CAAC,GAAGC,CAAzC,EAA4CD,CAAC,EAA7C,EAAiD;AAC/CuC,aAAC,GAAGrD,KAAK,CAACc,CAAD,CAAT;AACAuC,aAAC,IAAIA,CAAC,CAACnB,MAAP,IAAiBmB,CAAC,CAACnB,MAAF,CAASjC,GAAT,CAAamD,MAAb,EAAjB;AACD;AACF;AACF;;AACD,aAAOpD,KAAP;AACD,KArB6B;AAsB9B4C,OAAG,EAAE,SAASU,cAAT,CAAwBC,MAAxB,EAAgC;AACnC,UAAIvD,KAAK,GAAGyC,MAAM,GAAGA,MAAM,CAACQ,IAAP,CAAYrC,GAAZ,CAAH,GAAsBS,GAAxC;;AACA,UAAIkC,MAAM,KAAKvD,KAAf,EAAsB;AACpB;AACD;;AACD,UAAI2C,MAAJ,EAAY;AACVA,cAAM,CAACM,IAAP,CAAYrC,GAAZ,EAAiB2C,MAAjB;AACD,OAFD,MAEO;AACLlC,WAAG,GAAGkC,MAAN;AACD;;AACDV,aAAO,GAAG1B,OAAO,CAACoC,MAAD,CAAjB;AACAtD,SAAG,CAACuD,MAAJ;AACD;AAlC6B,GAAhC;AAoCD,C;;;;;;;;;;WCzOD,oD","file":"main.c1f0f805e8922a936c15.hot-update.js","sourcesContent":["import Dep from \"./dep\";\nimport { arrayMethods } from \"./array\";\nimport { def, isArray, isPlainObject, hasProto, hasOwn } from \"../util/index\";\n\nconst arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However in certain cases, e.g.\n * v-for scope alias and props, we don't want to force conversion\n * because the value may be a nested value under a frozen data structure.\n *\n * So whenever we want to set a reactive property without forcing\n * conversion on the new value, we wrap that call inside this function.\n */\n\nlet shouldConvert = true;\nexport function withoutConversion(fn) {\n  shouldConvert = false;\n  fn();\n  shouldConvert = true;\n}\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @param {Array|Object} value\n * @constructor\n */\n\nexport function Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  def(value, \"__ob__\", this);\n  //* NOTE: obviously, there different strategy for Array and Obj,\n  //* the do not share an observe function to observe changes.\n  //* maybe this is why my array is under observed better than Vue(change by index I mean)\n  if (isArray(value)) {\n    var augment = hasProto ? protoAugment : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n}\n\n// Instance methods\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n *\n * @param {Object} obj\n */\n\nObserver.prototype.walk = function (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    this.convert(keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n *\n * @param {Array} items\n */\n\nObserver.prototype.observeArray = function (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n/**\n * Convert a property into getter/setter so we can emit\n * the events when the property is accessed/changed.\n *\n * @param {String} key\n * @param {*} val\n */\n\nObserver.prototype.convert = function (key, val) {\n  defineReactive(this.value, key, val);\n};\n\n/**\n * Add an owner vm, so that when $set/$delete mutations\n * happen we can notify owner vms to proxy the keys and\n * digest the watchers. This is only called when the object\n * is observed as an instance's root $data.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.addVm = function (vm) {\n  (this.vms || (this.vms = [])).push(vm);\n};\n\n/**\n * Remove an owner vm. This is called when the object is\n * swapped out as an instance's $data object.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.removeVm = function (vm) {\n  this.vms.$remove(vm);\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n *\n * @param {Object|Array} target\n * @param {Object} src\n */\n\nfunction protoAugment(target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n *\n * @param {Object|Array} target\n * @param {Object} proto\n */\n\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @param {Vue} [vm]\n * @return {Observer|undefined}\n * @static\n */\n\nexport function observe(value, vm) {\n  if (!value || typeof value !== \"object\") {\n    return;\n  }\n  var ob;\n  if (hasOwn(value, \"__ob__\") && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    shouldConvert &&\n    (isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (ob && vm) {\n    ob.addVm(vm);\n  }\n  return ob;\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n */\n\nexport function defineReactive(obj, key, val) {\n  var dep = new Dep();\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return;\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        console.log(0);\n        dep.depend();\n        console.log(2);\n        if (childOb) {\n          console.log(3);\n          childOb.dep.depend();\n        }\n        if (isArray(value)) {\n          for (var e, i = 0, l = value.length; i < l; i++) {\n            e = value[i];\n            e && e.__ob__ && e.__ob__.dep.depend();\n          }\n        }\n      }\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      if (newVal === value) {\n        return;\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    },\n  });\n}\n","__webpack_require__.h = () => \"bd0e825cd0bc8d61c83e\""],"sourceRoot":""}